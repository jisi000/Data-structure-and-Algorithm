用列表模拟堆，对于每个节点i，其左子节点索引为2i+1，右子节点索引为2i+2。添加元素时，先加到末尾，然后自下而上调整；弹出堆顶时，为不破坏堆结构，把堆顶和堆尾交换，弹出堆尾，然后自上而下调整。

自下而上调整：如果当前节点存在父节点，且父节点值比当前节点大，就把当前节点和父节点交换，一直向上找父节点直到不存在父节点（到达堆顶）或父节点值比当前节点小。

自上而下调整：如果当前节点存在子节点，找到一个值最小的子节点，如果这个最小值比当前节点值小，就交换这个子节点和当前节点，一直向下找子节点直到不存在子节点或子节点最小值比当前节点大。

```python
class Heap:
    def __init__(self):
        self.tree=[]
    def down_to_up(self,i):
        while (i-1)//2>=0:
            if self.tree[i]<self.tree[(i-1)//2]:
                self.tree[i],self.tree[(i-1)//2]=self.tree[(i-1)//2],self.tree[i]
                i=(i-1)//2
            else:
                break
    def up_to_down(self,i):
        while i*2+1<len(self.tree):
            if i*2+2>=len(self.tree):
                child=i*2+1
            else:
                if self.tree[i*2+1]<=self.tree[i*2+2]:
                    child=i*2+1
                else:
                    child=i*2+2
            if self.tree[i]>self.tree[child]:
                self.tree[i],self.tree[child]=self.tree[child],self.tree[i]
                i=child
            else:
                break
    def heappush(self,num):
        self.tree.append(num)
        self.down_to_up(len(self.tree)-1)
    def heappop(self):
        if not self.tree:
            return None
        self.tree[0],self.tree[-1]=self.tree[-1],self.tree[0]
        ans=self.tree.pop()
        self.up_to_down(0)
        return ans
heap=Heap()
n=int(input())
for _ in range(n):
    l=list(map(int,input().split()))
    if l[0]==1:
        heap.heappush(l[1])
    elif l[0]==2:
        print(heap.heappop())
```

