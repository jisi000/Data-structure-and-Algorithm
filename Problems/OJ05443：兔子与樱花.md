将地点名称转换为从0到P-1的索引，地点之间的联通状态用矩阵表示。如果地点i和j之间有路径，将图的第i行，第j列的值标为路径长度。然后用dijkstra算法搜索。

```python
import heapq
P=int(input())
l=[input() for _ in range(P)]
graph=[[-1]*P for _ in range(P)]
Q=int(input())
for _ in range(Q):
    n1,n2,dis=input().split()
    i1,i2=l.index(n1),l.index(n2)
    graph[i1][i2]=graph[i2][i1]=int(dis)
def dijkstra(start,target):
    heap=[(0,start)]
    prev=[-1]*P
    dist=[float('inf')]*P
    dist[start]=0
    while heap:
        distance,loc=heapq.heappop(heap)
        if distance>dist[loc]:
            continue
        if loc==target:
            path=[loc]
            while prev[loc]!=-1:
                loc=prev[loc]
                path.append(loc)
            return path[::-1]
        for i in range(P):
            if graph[loc][i]!=-1:
                n_d=distance+graph[loc][i]
                if n_d<dist[i]:
                    dist[i]=n_d
                    prev[i]=loc
                    heapq.heappush(heap,(n_d,i))
    return []
R=int(input())
for _ in range(R):
    s,t=input().split()
    si,ti=l.index(s),l.index(t)
    ans=dijkstra(si,ti)
    answer=''
    for j in range(len(ans)-1):
        di=graph[ans[j]][ans[j+1]]
        answer+=f'{l[ans[j]]}->({di})->'
    answer+=l[ans[-1]]
    print(answer)
```

