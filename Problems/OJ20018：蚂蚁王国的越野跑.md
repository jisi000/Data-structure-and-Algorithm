直接把速度由大到小进行归并排序，在排序过程中统计赶超事件。

当把右边(b)与左边(a)合并时，如果b[j]>a[i]，说明b[j]会超越从a[i]到a[-1]的蚂蚁，数量为len(a)-i。

```python
N=int(input())
ants=[]
count=[0]
for t in range(N):
    ants.append(int(input()))
def merge(a,b):
    i,j=0,0
    ans=[]
    while i<len(a) and j<len(b):
        if a[i]<b[j]:
            ans.append(b[j])
            count[0]+=len(a)-i
            j+=1
        else:
            ans.append(a[i])
            i+=1
    ans+=a[i:] or b[j:]
    return ans
def merge_sort(l):
    if len(l)==1:
        return l
    mid=len(l)//2
    left=merge_sort(l[:mid])
    right=merge_sort(l[mid:])
    return merge(left,right)
n_ants=merge_sort(ants)
print(count[0])
```

