由于节点值互不相同，可以用邻接表存储树。

遍历节点时，先递归遍历比自身小的子节点，然后输出该节点的值，再递归遍历比自身大的子节点。

找到根节点，从根节点开始遍历。

```python
import bisect
d={}
child=set()
n=int(input())
for _ in range(n):
    line=list(map(int,input().split()))
    child.update(line[1:])
    d[line[0]]=line[1:]
root=-1
for num in d:
    if num not in child:
        root=num
def traversal(node):
    children=d[node]
    children.sort()
    lo=bisect.bisect_right(children,node)
    for m in children[:lo]:
        traversal(m)
    print(node)
    for m in children[lo:]:
        traversal(m)
traversal(root)
```

