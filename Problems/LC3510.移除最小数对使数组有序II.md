用最小堆判断哪对数对要合并，用双向链表存储数对的顺序信息，用一个动态变化的数字d存储逆序对的数量。当逆序对数量d为0时，结束循环，返回合并次数。

当两个数合并时，他们参与的其他数对就无效了，但从无法直接堆中删除无效数对。因此使用懒删除，给节点加上delete属性。

因为节点要放入堆中，为了防止运行出错，给节点加上_lt__函数。

把数对右边数字的索引放到堆中数组的第二位，当存在多个和最小的对，会弹出索引最小的，也就是最左边的。

```python
class Node:
    def __init__(self,val):
        self.val=val
        self.last=None
        self.next=None
        self.delete=False
    def __lt__(self,other):
        return self.val<other.val

class Solution:
    def minimumPairRemoval(self, nums: List[int]) -> int:
        import heapq
        heap=[]
        d=0
        node=Node(nums[0])
        for i in range(1,len(nums)):
            next_node=Node(nums[i])
            if node.val>next_node.val:
                d+=1
            heapq.heappush(heap,(node.val+next_node.val,i,node,next_node))
            node.next=next_node
            next_node.last=node
            node=node.next
        ans=0
        while heap and d>0:
            value,lo,node1,node2=heapq.heappop(heap)
            if node1.delete or node2.delete:
                continue
            ans+=1
            pre=node1.last
            nxt=node2.next
            if pre and pre.val>node1.val:
                d-=1
            if node1.val>node2.val:
                d-=1
            if nxt and node2.val>nxt.val:
                d-=1
            if pre and pre.val>value:
                d+=1
            if nxt and value>nxt.val:
                d+=1
            n_node=Node(value)
            node1.delete=True
            node2.delete=True
            if pre:
                pre.next=n_node
                n_node.last=pre
                heapq.heappush(heap,(pre.val+n_node.val,lo,pre,n_node))
            if nxt:
                n_node.next=nxt
                nxt.last=n_node
                heapq.heappush(heap,(n_node.val+nxt.val,lo+1,n_node,nxt))
        return ans
```

