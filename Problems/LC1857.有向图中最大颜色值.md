使用二维dp，dp[i] [j]代表从头走到第i个节点时第j个颜色在所有路径中的最大出现次数。在一般拓扑排序的基础上，增加对每个节点前端节点的记录，当遍历到这个节点时，取所有前端节点颜色出现次数的最大值。如果当前节点没有后端节点，把全部颜色出现次数中的最大值更新到答案上。

```python
class Solution:
    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:
        from collections import deque
        n=len(colors)
        color_list=[]
        d={}
        for c in colors:
            if c not in d:
                d[c]=len(color_list)
                color_list.append(c)
        m=len(color_list)
        in_degree=[0]*n
        graph=[[] for _ in range(n)]
        parent=[[] for _ in range(n)]
        for u,v in edges:
            in_degree[v]+=1
            graph[u].append(v)
            parent[v].append(u)
        dp=[[0]*m for _ in range(n)]
        queue=deque([u for u in range(n) if in_degree[u]==0])
        ans=0
        sequence=[]
        while queue:
            u=queue.popleft()
            sequence.append(u)
            re=d[colors[u]]
            if not parent[u]:
                dp[u][re]=dp[u][re]+1
            else:
                for v in parent[u]:
                    dp[u][re]=max(dp[u][re],dp[v][re]+1)
                    for i in range(m):
                        if i !=re:
                            dp[u][i]=max(dp[v][i],dp[u][i])
            if not graph[u]:
                for num in dp[u]:
                    ans=max(ans,num)
            else:
                for j in graph[u]:
                    in_degree[j]-=1
                    if in_degree[j]==0:
                        queue.append(j)
        if len(sequence)!=n:
            return -1
        return ans
```

